# Updates CHANGELOG.md when PRs are merged to main
# Uses intelligent categorization to generate changelog summaries
name: Update Changelog

on:
  pull_request:
    types:
      - closed
    branches:
      - main

permissions:
  contents: write
  pull-requests: read
  models: read

concurrency:
  group: changelog-update
  cancel-in-progress: false

jobs:
  update-changelog:
    # Only run when PR is actually merged, not just closed
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main

      - name: Get PR information
        id: pr-info
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          # Pass PR data as env vars to avoid shell injection from backticks/special chars
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          PR_URL: ${{ github.event.pull_request.html_url }}
        run: |
          # Output PR details safely using environment variables
          echo "title=${PR_TITLE}" >> "$GITHUB_OUTPUT"
          echo "author=${PR_AUTHOR}" >> "$GITHUB_OUTPUT"
          echo "url=${PR_URL}" >> "$GITHUB_OUTPUT"
          echo "number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"
          
          # Get changed files
          CHANGED_FILES=$(gh pr view "$PR_NUMBER" --json files --jq '.files[].path' | head -30)
          echo "changed_files<<EOF" >> "$GITHUB_OUTPUT"
          echo "$CHANGED_FILES" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          
          # Get commit messages from PR
          COMMITS=$(gh pr view "$PR_NUMBER" --json commits --jq '.commits[].messageHeadline' | head -20)
          echo "commits<<EOF" >> "$GITHUB_OUTPUT"
          echo "$COMMITS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          
          # Store PR body for later use (using heredoc to handle special chars)
          echo "body<<EOF" >> "$GITHUB_OUTPUT"
          echo "$PR_BODY" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Get diff summary
        id: diff-summary
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          # Get a concise diff stat
          DIFF_STAT=$(gh pr diff "$PR_NUMBER" --stat 2>/dev/null | tail -1 || echo "Changes not available")
          echo "stat=${DIFF_STAT}" >> "$GITHUB_OUTPUT"

      - name: Read current version
        id: version
        run: |
          if [ -f VERSION ]; then
            VERSION=$(cat VERSION | tr -d '[:space:]')
          else
            VERSION="Unreleased"
          fi
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"

      - name: Generate changelog entry with GitHub Models
        id: ai-summary
        env:
          GITHUB_TOKEN: ${{ github.token }}
          PR_TITLE: ${{ steps.pr-info.outputs.title }}
          PR_NUMBER: ${{ steps.pr-info.outputs.number }}
          PR_AUTHOR: ${{ steps.pr-info.outputs.author }}
          PR_BODY: ${{ steps.pr-info.outputs.body }}
          PR_COMMITS: ${{ steps.pr-info.outputs.commits }}
          PR_FILES: ${{ steps.pr-info.outputs.changed_files }}
          DIFF_STAT: ${{ steps.diff-summary.outputs.stat }}
          REPO: ${{ github.repository }}
        run: |
          PR_URL="https://github.com/${REPO}/pull/${PR_NUMBER}"
          
          # Build the prompt
          PROMPT="You are a technical writer creating a changelog entry for a software project.

          Analyze the following pull request and generate a clear, concise changelog entry.

          ## Pull Request Information
          - Title: ${PR_TITLE}
          - PR Number: #${PR_NUMBER}
          - Author: @${PR_AUTHOR}
          - Changes: ${DIFF_STAT}

          ## PR Description
          ${PR_BODY}

          ## Commits
          ${PR_COMMITS}

          ## Files Changed
          ${PR_FILES}

          ## Instructions
          1. Categorize as ONE of: Added, Changed, Fixed, Removed, Security, Deprecated
          2. Write a clear, user-focused summary (1-2 sentences max)
          3. Focus on WHAT changed and WHY it matters
          4. Use present tense (Add not Added)

          Respond with ONLY a JSON object in this exact format, no other text:
          {\"category\": \"Added|Changed|Fixed|Removed|Security|Deprecated\", \"summary\": \"Your summary here\"}"

          # Escape the prompt for JSON
          ESCAPED_PROMPT=$(echo "$PROMPT" | jq -Rs .)
          
          # Build request body
          REQUEST_BODY=$(cat <<EOF
          {
            "messages": [
              {
                "role": "user",
                "content": ${ESCAPED_PROMPT}
              }
            ],
            "model": "gpt-4o",
            "max_tokens": 200,
            "temperature": 0.3
          }
          EOF
          )
          
          # Call GitHub Models API (available to Copilot Pro+ subscribers)
          RESPONSE=$(curl -s -X POST \
            "https://models.inference.ai.azure.com/chat/completions" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$REQUEST_BODY" 2>/dev/null || echo "")
          
          # Extract the content from the response
          AI_CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty' 2>/dev/null || echo "")
          
          if [ -n "$AI_CONTENT" ]; then
            # Parse the JSON response from the AI
            CATEGORY=$(echo "$AI_CONTENT" | jq -r '.category // empty' 2>/dev/null || echo "")
            SUMMARY=$(echo "$AI_CONTENT" | jq -r '.summary // empty' 2>/dev/null || echo "")
            
            if [ -n "$CATEGORY" ] && [ -n "$SUMMARY" ]; then
              echo "ai_category=${CATEGORY}" >> "$GITHUB_OUTPUT"
              echo "ai_summary=${SUMMARY}" >> "$GITHUB_OUTPUT"
              echo "ai_success=true" >> "$GITHUB_OUTPUT"
              echo "‚úÖ AI generated changelog entry"
            else
              echo "ai_success=false" >> "$GITHUB_OUTPUT"
              echo "‚ö†Ô∏è Could not parse AI response, using fallback"
            fi
          else
            echo "ai_success=false" >> "$GITHUB_OUTPUT"
            echo "‚ö†Ô∏è No AI response, using fallback categorization"
          fi
          
          echo "pr_url=${PR_URL}" >> "$GITHUB_OUTPUT"

      - name: Prepare changelog entry
        id: prepare-entry
        env:
          AI_SUCCESS: ${{ steps.ai-summary.outputs.ai_success }}
          AI_CATEGORY: ${{ steps.ai-summary.outputs.ai_category }}
          AI_SUMMARY: ${{ steps.ai-summary.outputs.ai_summary }}
          PR_TITLE: ${{ steps.pr-info.outputs.title }}
          PR_NUMBER: ${{ steps.pr-info.outputs.number }}
          PR_URL: ${{ steps.ai-summary.outputs.pr_url }}
          PR_AUTHOR: ${{ steps.pr-info.outputs.author }}
          PR_BODY: ${{ steps.pr-info.outputs.body }}
          PR_FILES: ${{ steps.pr-info.outputs.changed_files }}
          REPO: ${{ github.repository }}
        run: |
          # Use AI-generated entry if available, otherwise fall back to heuristics
          if [ "$AI_SUCCESS" = "true" ] && [ -n "$AI_CATEGORY" ] && [ -n "$AI_SUMMARY" ]; then
            CATEGORY="$AI_CATEGORY"
            SUMMARY="$AI_SUMMARY"
            echo "üìù Using AI-generated changelog entry"
          else
            echo "üìù Using fallback categorization"
            
            # Fallback: Determine category based on PR title
            title_lower=$(echo "$PR_TITLE" | tr '[:upper:]' '[:lower:]')
            
            if [[ "$title_lower" =~ (security|vulnerability|cve|exploit) ]]; then
              CATEGORY="Security"
            elif [[ "$title_lower" =~ (fix|bug|issue|resolve|patch|repair|correct) ]]; then
              CATEGORY="Fixed"
            elif [[ "$title_lower" =~ (remove|delete|drop) ]]; then
              CATEGORY="Removed"
            elif [[ "$title_lower" =~ (deprecate) ]]; then
              CATEGORY="Deprecated"
            elif [[ "$title_lower" =~ (add|new|feature|implement|create|introduce) ]]; then
              CATEGORY="Added"
            else
              CATEGORY="Changed"
            fi
            
            # Clean up PR title for summary
            SUMMARY=$(echo "$PR_TITLE" | sed -E 's/^(feat|fix|docs|style|refactor|test|chore|ci|perf|build)(\([^)]*\))?:\s*//i')
            SUMMARY="$(echo "${SUMMARY:0:1}" | tr '[:lower:]' '[:upper:]')${SUMMARY:1}"
          fi
          
          # Build the entry
          ENTRY="### ${CATEGORY}
          - ${SUMMARY} ([#${PR_NUMBER}](${PR_URL}))"
          
          echo "entry<<EOF" >> "$GITHUB_OUTPUT"
          echo "$ENTRY" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          
          echo "category=${CATEGORY}" >> "$GITHUB_OUTPUT"

      - name: Update CHANGELOG.md
        env:
          VERSION: ${{ steps.version.outputs.version }}
          ENTRY: ${{ steps.prepare-entry.outputs.entry }}
          PR_NUMBER: ${{ steps.pr-info.outputs.number }}
        run: |
          DATE=$(date +%Y-%m-%d)
          
          # Create CHANGELOG.md if it doesn't exist
          if [ ! -f CHANGELOG.md ]; then
            cat > CHANGELOG.md << 'HEADER'
          # Changelog

          All notable changes to this project will be documented in this file.

          The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
          and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

          HEADER
          fi
          
          # Check if version section exists
          if grep -q "## \[${VERSION}\]" CHANGELOG.md; then
            # Append to existing version section
            # Find the line with the version header and insert after it
            sed -i.bak "/## \[${VERSION}\]/a\\
          \\
          ${ENTRY}
          " CHANGELOG.md
            rm -f CHANGELOG.md.bak
          else
            # Create new version section after the header
            # Insert after the header line or at line 8 if no header pattern found
            if grep -q "^# Changelog" CHANGELOG.md; then
              # Find position after header section (after empty line following header)
              awk -v version="$VERSION" -v date="$DATE" -v entry="$ENTRY" '
                /^# Changelog/ { print; header=1; next }
                header && /^$/ && !inserted { 
                  print ""
                  print "## [" version "] - " date
                  print ""
                  print entry
                  print ""
                  inserted=1
                  next
                }
                { print }
              ' CHANGELOG.md > CHANGELOG.tmp && mv CHANGELOG.tmp CHANGELOG.md
            else
              # Prepend if no standard header found
              {
                echo "## [${VERSION}] - ${DATE}"
                echo ""
                echo "$ENTRY"
                echo ""
                cat CHANGELOG.md
              } > CHANGELOG.tmp && mv CHANGELOG.tmp CHANGELOG.md
            fi
          fi
          
          echo "üìù Updated CHANGELOG.md with entry for PR #${PR_NUMBER}"

      - name: Commit and push changelog
        env:
          PR_NUMBER: ${{ steps.pr-info.outputs.number }}
          PR_TITLE: ${{ steps.pr-info.outputs.title }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check if there are changes to commit
          if git diff --quiet CHANGELOG.md; then
            echo "No changes to CHANGELOG.md"
            exit 0
          fi
          
          git add CHANGELOG.md
          git commit -m "docs: update changelog for PR #${PR_NUMBER}

          ${PR_TITLE}

          [skip ci]"
          
          git push origin main
          echo "‚úÖ Pushed changelog update"

      - name: Summary
        env:
          VERSION: ${{ steps.version.outputs.version }}
          ENTRY: ${{ steps.prepare-entry.outputs.entry }}
          PR_NUMBER: ${{ steps.pr-info.outputs.number }}
          PR_URL: ${{ steps.pr-info.outputs.url }}
        run: |
          {
            echo "### üìù Changelog Updated"
            echo ""
            echo "Added entry for [PR #${PR_NUMBER}](${PR_URL}) to version \`${VERSION}\`"
            echo ""
            echo "#### Entry Added"
            echo ""
            echo "$ENTRY"
          } >> "$GITHUB_STEP_SUMMARY"
