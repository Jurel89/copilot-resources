#!/usr/bin/env node
/**
 * @fileoverview Cross-platform Copilot assets synchronization script.
 *
 * PURPOSE:
 *   Synchronize GitHub Copilot customization assets (agents, instructions, prompts, skills)
 *   from the copilot-resources repository to multiple target repositories.
 *
 * DESCRIPTION:
 *   This script performs a full overwrite sync using Node.js built-in APIs.
 *   Files in target repositories that don't exist in source are deleted.
 *   Target repositories are specified in sync-targets.txt (one path per line).
 *
 *   Replaces the Bash/rsync implementation for cross-platform compatibility.
 *   Works identically on Windows, macOS, and Linux without additional setup.
 *
 * USAGE:
 *   node .github/skills/sync-copilot-assets/scripts/sync-copilot-assets.mjs [OPTIONS]
 *
 * OPTIONS:
 *   -n, --dry-run     Preview changes without modifying files
 *   -q, --quiet       Suppress non-error output
 *   -h, --help        Show this help message
 *   -v, --version     Show script version
 *
 * CONFIGURATION:
 *   Reads target paths from: ${REPO_ROOT}/sync-targets.txt
 *
 * EXIT CODES:
 *   0    All targets synced successfully
 *   1    Partial success (some targets failed)
 *   2    Critical failure (missing source, invalid config, Node.js version)
 *
 * EXAMPLES:
 *   # Preview what would be synced
 *   node .github/skills/sync-copilot-assets/scripts/sync-copilot-assets.mjs --dry-run
 *
 *   # Run full sync
 *   node .github/skills/sync-copilot-assets/scripts/sync-copilot-assets.mjs
 *
 *   # Quiet mode for scripting
 *   node .github/skills/sync-copilot-assets/scripts/sync-copilot-assets.mjs --quiet
 *
 * AUTHOR:
 *   Generated by Metaprompter Agent
 *
 * VERSION:
 *   2.1.0
 *
 * REQUIRES:
 *   - Node.js 18.x or later
 *
 * @requires node:fs
 * @requires node:path
 * @requires node:url
 * @license MIT
 */

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

// ==============================================================================
// Configuration
// ==============================================================================

const VERSION = '2.1.0';
const MIN_NODE_VERSION = 18;

/** @type {string} */
const __filename = fileURLToPath(import.meta.url);
/** @type {string} */
const __dirname = path.dirname(__filename);

/**
 * Finds the repository root by looking for sync-targets.txt or .github directory
 * at the SAME level (indicating repo root, not inside .github).
 * Walks up from the script location until found.
 * @returns {string} Absolute path to repository root
 */
function findRepoRoot() {
  // Script is in .github/skills/sync-copilot-assets/scripts/
  // So repo root is 4 levels up
  let current = __dirname;
  
  for (let i = 0; i < 10; i++) {
    const configPath = path.join(current, 'sync-targets.txt');
    const githubPath = path.join(current, '.github');
    
    // Check for sync-targets.txt (definitive marker of repo root)
    if (fs.existsSync(configPath)) {
      return current;
    }
    
    // Check for .github as a CHILD directory (not when we're inside .github)
    // This ensures we find the repo root, not .github itself
    if (fs.existsSync(githubPath) && fs.statSync(githubPath).isDirectory()) {
      // Verify this is the repo root by checking that current dir is not named '.github'
      if (path.basename(current) !== '.github') {
        return current;
      }
    }
    
    const parent = path.dirname(current);
    if (parent === current) {
      // Reached filesystem root
      break;
    }
    current = parent;
  }
  
  // Fallback: assume 4 levels up from script
  return path.resolve(__dirname, '../../../..');
}

/** @type {string} */
const REPO_ROOT = findRepoRoot();
/** @type {string} */
const CONFIG_FILE = path.join(REPO_ROOT, 'sync-targets.txt');

/** @type {string[]} Source directories relative to repo root */
const SOURCE_DIRS = [
  '.github/agents',
  '.github/instructions',
  '.github/prompts',
  '.github/skills',
];

// ==============================================================================
// Color Support
// ==============================================================================

/** @type {boolean} */
const supportsColor = process.stdout.isTTY && !process.env.NO_COLOR;

const colors = {
  red: supportsColor ? '\x1b[0;31m' : '',
  green: supportsColor ? '\x1b[0;32m' : '',
  yellow: supportsColor ? '\x1b[0;33m' : '',
  blue: supportsColor ? '\x1b[0;34m' : '',
  bold: supportsColor ? '\x1b[1m' : '',
  nc: supportsColor ? '\x1b[0m' : '',
};

// ==============================================================================
// Global State
// ==============================================================================

/** @type {boolean} */
let dryRun = false;
/** @type {boolean} */
let quiet = false;
/** @type {number} */
let targetsTotal = 0;
/** @type {number} */
let targetsSuccess = 0;
/** @type {number} */
let targetsFailed = 0;
/** @type {number} */
let targetsSkipped = 0;
/** @type {string[]} */
const failedTargets = [];
/** @type {number} */
let startTime = 0;

// ==============================================================================
// Logging Utilities
// ==============================================================================

/**
 * Logs an info message if not in quiet mode.
 * @param {string} message - The message to log
 */
function logInfo(message) {
  if (!quiet) {
    console.log(message);
  }
}

/**
 * Logs an error message to stderr.
 * @param {string} message - The error message
 */
function logError(message) {
  console.error(`${colors.red}ERROR:${colors.nc} ${message}`);
}

/**
 * Logs a warning message if not in quiet mode.
 * @param {string} message - The warning message
 */
function logWarning(message) {
  if (!quiet) {
    console.log(`${colors.yellow}WARNING:${colors.nc} ${message}`);
  }
}

// ==============================================================================
// Display Functions
// ==============================================================================

/**
 * Prints the script header with timestamp and configuration.
 */
function printHeader() {
  if (quiet) return;

  console.log(`${colors.bold}╔════════════════════════════════════════════════════════════════╗${colors.nc}`);
  console.log(`${colors.bold}║          Copilot Assets Sync                                   ║${colors.nc}`);
  console.log(`${colors.bold}╚════════════════════════════════════════════════════════════════╝${colors.nc}`);
  console.log('');
  console.log(`  ${colors.blue}Started:${colors.nc} ${new Date().toISOString().replace('T', ' ').slice(0, 19)}`);
  console.log(`  ${colors.blue}Source:${colors.nc}  ${REPO_ROOT}`);
  if (dryRun) {
    console.log(`  ${colors.yellow}Mode:${colors.nc}    ${colors.yellow}DRY-RUN (no changes will be made)${colors.nc}`);
  }
  console.log('');
  console.log(`${colors.bold}────────────────────────────────────────────────────────────────${colors.nc}`);
}

/**
 * Prints detailed usage information.
 */
function printUsage() {
  const scriptPath = '.github/skills/sync-copilot-assets/scripts/sync-copilot-assets.mjs';
  console.log(`
${colors.bold}NAME${colors.nc}
    sync-copilot-assets.mjs - Sync Copilot assets to target repositories

${colors.bold}SYNOPSIS${colors.nc}
    node ${scriptPath} [OPTIONS]

${colors.bold}DESCRIPTION${colors.nc}
    Synchronizes GitHub Copilot customization assets (agents, instructions,
    prompts, skills) from this repository to multiple target repositories.
    
    Performs full overwrite synchronization using Node.js built-in APIs.
    Works identically on Windows, macOS, and Linux.
    Target repositories are configured in sync-targets.txt.

${colors.bold}OPTIONS${colors.nc}
    -n, --dry-run     Preview changes without modifying files.
                      Shows what would be added, modified, or deleted.
    
    -q, --quiet       Suppress non-error output.
                      Only errors and the final summary are shown.
    
    -h, --help        Display this help message and exit.
    
    -v, --version     Display version information and exit.

${colors.bold}CONFIGURATION${colors.nc}
    Target paths are read from: ${CONFIG_FILE}
    
    Format: One absolute path per line. Lines starting with # are comments.
    Empty lines are ignored. Paths with spaces are supported.

${colors.bold}EXIT CODES${colors.nc}
    0    All targets synced successfully
    1    Partial success (some targets failed or were skipped)
    2    Critical failure (missing source directories, no config file)

${colors.bold}EXAMPLES${colors.nc}
    # Preview what would be synced
    node ${scriptPath} --dry-run
    
    # Run full sync
    node ${scriptPath}
    
    # Quiet mode for scripting
    node ${scriptPath} --quiet

${colors.bold}SYNCED DIRECTORIES${colors.nc}
    .github/agents/       Agent definition files
    .github/instructions/ Instruction files for code generation
    .github/prompts/      Reusable prompt files
    .github/skills/       Skill folders with resources

${colors.bold}WARNING${colors.nc}
    This script performs FULL OVERWRITE synchronization.
    Files in target repositories that don't exist in source WILL BE DELETED.
    Always use --dry-run first to preview changes.

${colors.bold}REQUIRES${colors.nc}
    Node.js ${MIN_NODE_VERSION}.x or later
`);
}

/**
 * Prints the script version.
 */
function printVersion() {
  console.log(`sync-copilot-assets.mjs version ${VERSION}`);
}

/**
 * Prints the sync summary with statistics.
 */
function printSummary() {
  const endTime = Date.now();
  const elapsed = Math.round((endTime - startTime) / 1000);

  console.log('');
  console.log(`${colors.bold}────────────────────────────────────────────────────────────────${colors.nc}`);
  console.log(`${colors.bold}Summary${colors.nc}`);
  console.log(`${colors.bold}────────────────────────────────────────────────────────────────${colors.nc}`);
  console.log('');

  if (dryRun) {
    console.log(`  ${colors.yellow}DRY-RUN MODE - No files were modified${colors.nc}`);
    console.log('');
  }

  console.log(`  Total targets:  ${targetsTotal}`);
  console.log(`  ${colors.green}Succeeded:${colors.nc}      ${targetsSuccess}`);
  console.log(`  ${colors.red}Failed:${colors.nc}         ${targetsFailed}`);
  console.log(`  ${colors.yellow}Skipped:${colors.nc}        ${targetsSkipped}`);
  console.log('');
  console.log(`  Elapsed time:   ${elapsed}s`);
  console.log('');

  if (failedTargets.length > 0) {
    console.log(`${colors.red}Failed targets:${colors.nc}`);
    for (const target of failedTargets) {
      console.log(`  - ${target}`);
    }
    console.log('');
  }

  if (targetsFailed === 0 && targetsSkipped === 0) {
    console.log(`${colors.green}✅ All targets synced successfully!${colors.nc}`);
  } else if (targetsSuccess > 0) {
    console.log(`${colors.yellow}⚠️  Partial success. Review warnings above.${colors.nc}`);
  } else {
    console.log(`${colors.red}❌ Sync failed for all targets.${colors.nc}`);
  }
  console.log('');
}

// ==============================================================================
// Validation Functions
// ==============================================================================

/**
 * Checks if the Node.js version meets minimum requirements.
 * Exits with code 2 if version is too old.
 */
function checkNodeVersion() {
  const nodeVersion = parseInt(process.versions.node.split('.')[0], 10);
  if (nodeVersion < MIN_NODE_VERSION) {
    logError(`Node.js ${MIN_NODE_VERSION}.x or later is required. Current version: ${process.versions.node}`);
    console.log('');
    console.log('Update Node.js:');
    console.log('  https://nodejs.org/');
    process.exit(2);
  }
}

/**
 * Validates that all source directories exist.
 * Exits with code 2 if any are missing.
 */
function validateSourceDirectories() {
  const missing = [];

  for (const dir of SOURCE_DIRS) {
    const fullPath = path.join(REPO_ROOT, dir);
    if (!fs.existsSync(fullPath)) {
      missing.push(dir);
    }
  }

  if (missing.length > 0) {
    logError('Source directories not found:');
    for (const dir of missing) {
      console.log(`  - ${dir}`);
    }
    console.log('');
    console.log('Ensure you\'re running from the copilot-resources repository.');
    process.exit(2);
  }
}

/**
 * Validates that the configuration file exists.
 * Exits with code 2 if missing.
 */
function validateConfigFile() {
  if (!fs.existsSync(CONFIG_FILE)) {
    logError(`Configuration file not found: ${CONFIG_FILE}`);
    console.log('');
    console.log('Create sync-targets.txt with one target repository path per line.');
    console.log('Example:');
    console.log('  # My project repositories');
    console.log('  /Users/username/projects/project-alpha');
    console.log('  /Users/username/projects/project-beta');
    process.exit(2);
  }
}

// ==============================================================================
// File System Utilities
// ==============================================================================

/**
 * Recursively gets all files in a directory, returning paths relative to the directory.
 * @param {string} dir - The directory to scan
 * @param {string} [baseDir] - The base directory for relative paths (defaults to dir)
 * @returns {string[]} Array of relative file paths
 */
function getAllFilesRelative(dir, baseDir = dir) {
  const files = [];

  if (!fs.existsSync(dir)) {
    return files;
  }

  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relativePath = path.relative(baseDir, fullPath);

    if (entry.isDirectory()) {
      files.push(...getAllFilesRelative(fullPath, baseDir));
    } else {
      files.push(relativePath);
    }
  }

  return files;
}

/**
 * Ensures a directory exists, creating it recursively if needed.
 * @param {string} dirPath - The directory path to create
 */
function ensureDir(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

/**
 * Synchronizes a source directory to a target directory with delete behavior.
 * Files in target that don't exist in source are removed.
 *
 * @param {string} sourceDir - Absolute path to source directory
 * @param {string} targetDir - Absolute path to target directory
 * @returns {{ added: number, updated: number, deleted: number, errors: string[] }}
 */
function syncDirectory(sourceDir, targetDir) {
  const result = { added: 0, updated: 0, deleted: 0, errors: [] };

  try {
    // Step 1: Get all files in source (recursive)
    const sourceFiles = getAllFilesRelative(sourceDir);

    // Step 2: Get all files in target (recursive)
    const targetFiles = getAllFilesRelative(targetDir);

    // Step 3: Copy all source files to target
    for (const file of sourceFiles) {
      const srcPath = path.join(sourceDir, file);
      const destPath = path.join(targetDir, file);
      const destDir = path.dirname(destPath);

      const exists = fs.existsSync(destPath);

      if (!dryRun) {
        ensureDir(destDir);
        fs.copyFileSync(srcPath, destPath);
      }

      if (exists) {
        result.updated++;
        if (!quiet) {
          logInfo(`      ${colors.blue}↻${colors.nc} ${file}`);
        }
      } else {
        result.added++;
        if (!quiet) {
          logInfo(`      ${colors.green}+${colors.nc} ${file}`);
        }
      }
    }

    // Step 4: Delete files in target that don't exist in source
    const sourceSet = new Set(sourceFiles);
    for (const file of targetFiles) {
      if (!sourceSet.has(file)) {
        const targetPath = path.join(targetDir, file);

        if (!dryRun) {
          try {
            fs.rmSync(targetPath, { force: true });
          } catch (err) {
            result.errors.push(`Failed to delete ${file}: ${err.message}`);
            continue;
          }
        }

        result.deleted++;
        if (!quiet) {
          logInfo(`      ${colors.red}-${colors.nc} ${file}`);
        }
      }
    }

    // Step 5: Clean up empty directories in target
    if (!dryRun) {
      cleanEmptyDirs(targetDir);
    }
  } catch (err) {
    result.errors.push(err.message);
  }

  return result;
}

/**
 * Recursively removes empty directories.
 * @param {string} dir - The directory to clean
 */
function cleanEmptyDirs(dir) {
  if (!fs.existsSync(dir)) return;

  let entries = fs.readdirSync(dir, { withFileTypes: true });

  // Recursively clean subdirectories first
  for (const entry of entries) {
    if (entry.isDirectory()) {
      cleanEmptyDirs(path.join(dir, entry.name));
    }
  }

  // Re-read after cleaning subdirectories
  entries = fs.readdirSync(dir);

  // Remove if empty (but not the root target .github dir)
  if (entries.length === 0) {
    fs.rmdirSync(dir);
  }
}

// ==============================================================================
// Target Processing
// ==============================================================================

/**
 * Reads target paths from the configuration file.
 * @returns {string[]} Array of target paths
 */
function readTargets() {
  const content = fs.readFileSync(CONFIG_FILE, 'utf-8');
  const lines = content.split(/\r?\n/);
  const targets = [];

  for (let line of lines) {
    // Remove inline comments
    const commentIndex = line.indexOf('#');
    if (commentIndex !== -1) {
      line = line.slice(0, commentIndex);
    }

    // Trim whitespace
    line = line.trim();

    // Skip empty lines
    if (line) {
      // Normalize path separators for the current OS
      targets.push(path.normalize(line));
    }
  }

  if (targets.length === 0) {
    logError(`No target paths found in ${CONFIG_FILE}`);
    console.log('');
    console.log('Add at least one target repository path to sync-targets.txt');
    process.exit(2);
  }

  return targets;
}

/**
 * Synchronizes all asset directories to a single target repository.
 * @param {string} target - The target repository path
 * @returns {boolean} True if sync succeeded, false otherwise
 */
function syncToTarget(target) {
  const targetName = path.basename(target);

  // Validate target path exists
  if (!fs.existsSync(target)) {
    logWarning(`Target path does not exist: ${target}`);
    targetsSkipped++;
    return false;
  }

  logInfo('');
  logInfo(`  ${colors.blue}→${colors.nc} Syncing to: ${colors.bold}${targetName}${colors.nc}`);
  logInfo(`    ${target}`);

  let syncErrors = 0;
  let totalAdded = 0;
  let totalUpdated = 0;
  let totalDeleted = 0;

  for (const dir of SOURCE_DIRS) {
    const sourcePath = path.join(REPO_ROOT, dir);
    const targetPath = path.join(target, dir);

    if (!quiet) {
      logInfo(`    ${colors.blue}${dir}/${colors.nc}`);
    }

    const result = syncDirectory(sourcePath, targetPath);

    totalAdded += result.added;
    totalUpdated += result.updated;
    totalDeleted += result.deleted;

    if (result.errors.length > 0) {
      syncErrors += result.errors.length;
      for (const err of result.errors) {
        logError(`  ${err}`);
      }
    }
  }

  if (syncErrors === 0) {
    logInfo(`    ${colors.green}✅ Success${colors.nc} (+${totalAdded} ↻${totalUpdated} -${totalDeleted})`);
    targetsSuccess++;
    return true;
  } else {
    logInfo(`    ${colors.red}❌ Failed (${syncErrors} errors)${colors.nc}`);
    targetsFailed++;
    failedTargets.push(target);
    return false;
  }
}

// ==============================================================================
// CLI Argument Parsing
// ==============================================================================

/**
 * Parses command line arguments.
 * @param {string[]} args - The command line arguments
 */
function parseArgs(args) {
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    switch (arg) {
      case '-n':
      case '--dry-run':
        dryRun = true;
        break;

      case '-q':
      case '--quiet':
        quiet = true;
        break;

      case '-h':
      case '--help':
        printUsage();
        process.exit(0);
        break;

      case '-v':
      case '--version':
        printVersion();
        process.exit(0);
        break;

      default:
        logError(`Unknown option: ${arg}`);
        console.log('Use --help for usage information.');
        process.exit(2);
    }
  }
}

// ==============================================================================
// Main Entry Point
// ==============================================================================

/**
 * Main function that orchestrates the sync process.
 */
function main() {
  // Parse command line arguments (skip node and script path)
  parseArgs(process.argv.slice(2));

  // Record start time
  startTime = Date.now();

  // Pre-flight checks
  checkNodeVersion();
  validateSourceDirectories();
  validateConfigFile();

  // Print header
  printHeader();

  // Read targets and sync
  const targets = readTargets();
  targetsTotal = targets.length;

  logInfo(`Found ${targetsTotal} target(s) to sync`);

  for (const target of targets) {
    syncToTarget(target);
  }

  // Print summary
  printSummary();

  // Exit with appropriate code
  if (targetsFailed > 0 || targetsSkipped > 0) {
    process.exit(1);
  }
  process.exit(0);
}

// Run main
main();
