---
description: 'Fully automate organizing uncommitted changes into documented issues, branches, PRs, and merges to the version development branch'
name: 'organize-chaos'
agent: 'The GitChaos Organizer'
tools: ['execute', 'read', 'agent', 'edit', 'search', 'todo']
argument-hint: 'Optional: specific files or scope to organize (leave empty for all changes)'
---

# Organize Git Chaos into Production-Ready Workflow

## Mission

Execute a **complete, end-to-end workflow** to transform all uncommitted local changes into properly documented, tracked, and merged development work. This is a fully automated operation‚Äîproceed through all phases without waiting for user confirmation between steps unless a critical decision or error requires intervention.

---

## Workflow Overview

Execute these phases **in sequence and to completion**:

1. **Deep Analysis** ‚Äî Thoroughly analyze all uncommitted changes
2. **Issue Creation** ‚Äî Create detailed, documented GitHub issues for each logical group
3. **Branch & Commit** ‚Äî Create feature branches and conventional commits
4. **PR Creation** ‚Äî Open PRs targeting `v{version}/development`
5. **CI Monitoring** ‚Äî Wait for all CI workflows/checks to pass
6. **Merge & Close** ‚Äî Merge PRs and verify issue closure
7. **Cleanup & Report** ‚Äî Clean up branches and provide final summary

---

## Phase 1: Deep Analysis

### Step 1.1: Capture Current State

```bash
# Get comprehensive status
git status --porcelain

# Get detailed diff with stats
git diff --stat

# Get full diff for analysis
git diff

# Identify current branch
git branch --show-current
```

### Step 1.2: Read VERSION File

```bash
# Get current version for branch targeting
cat VERSION
```

Store the version as `{version}` for use in branch naming (e.g., `v1.2.0/development`).

### Step 1.3: Analyze Each Change

For **every modified, added, or deleted file**:

1. **Read the full diff** to understand the exact changes
2. **Determine the PURPOSE**: Feature, Bug Fix, Hotfix, Technical Chore, Documentation, Performance, Security, Infrastructure
3. **Identify DEPENDENCIES**: Files that must be committed together
4. **Extract CONTEXT**: Why this change was made (from code comments, variable names, etc.)
5. **Assess COMPLEXITY**: Simple change vs. significant refactor

### Step 1.4: Group Changes Intelligently

Cluster related changes based on:

- **Functional cohesion**: Files that implement the same feature
- **Module boundaries**: Changes within a single component/module
- **Fix scope**: Changes that address a single issue
- **Dependency graph**: Files that import/reference each other

**Rule**: Each group = ONE logical unit of work = ONE issue = ONE branch = ONE PR

---

## Phase 2: Issue Creation

### Step 2.1: Query Existing Issues

Before creating any issue, determine the next available ID for each prefix:

```bash
# Query existing issues for each prefix type you'll use
gh issue list --search "FR-" --limit 1000 --json number,title | jq -r '.[].title' | grep -oP 'FR-\d{4}' | sort -t'-' -k2 -n | tail -1

# Repeat for: BG-, HF-, TC-, SC-, PF-, DC-, IN-
```

### Step 2.2: Create Issues

For **each logical group**, create a GitHub issue using this structure:

```markdown
## Summary

[Detailed description of what this group of changes accomplishes]

## Requirement Details

- **Requirement ID**: [PREFIX-####]
- **Type**: [Feature Request | Bug Fix | Hotfix | Technical Chore | Documentation | Performance | Security | Infrastructure]
- **Priority**: [P1-High | P2-Medium | P3-Low]
- **Source**: Extracted from uncommitted local changes

## Changes Included

| File | Change Type | Description |
|------|-------------|-------------|
| `path/to/file.ext` | Modified/Added/Deleted | [What changed and why] |

## Acceptance Criteria

- [ ] AC-001: [Derived from actual code changes]
- [ ] AC-002: [Verification criteria]

## Technical Notes

[Implementation details extracted from the code]

## Testing Requirements

- [ ] Verification: [How to verify this works]

---
*Auto-generated by The GitChaos Organizer*
```

**Command**:

```bash
gh issue create \
  --title "[PREFIX-####] Descriptive Title" \
  --body "[Full body from template]" \
  --label "type:feature,priority:medium"
```

**Capture the issue number** from the output for linking in PRs.

---

## Phase 3: Branch, Commit & PR

For **each issue created**, execute these steps in order:

### Step 3.1: Ensure Clean Starting Point

```bash
# Checkout development branch
git checkout v{version}/development

# Pull latest
git pull origin v{version}/development
```

### Step 3.2: Create Feature Branch

Branch naming pattern: `{type}/{issue-id}-{short-description}`

| Type | Prefix | Branch Pattern |
|------|--------|----------------|
| Feature | FR- | `feature/FR-####-description` |
| Bug Fix | BG- | `bugfix/BG-####-description` |
| Hotfix | HF- | `hotfix/HF-####-description` |
| Technical Chore | TC- | `chore/TC-####-description` |
| Security | SC- | `security/SC-####-description` |
| Performance | PF- | `perf/PF-####-description` |
| Documentation | DC- | `docs/DC-####-description` |
| Infrastructure | IN- | `infra/IN-####-description` |

```bash
git checkout -b feature/FR-####-short-description
```

### Step 3.3: Stage ONLY Related Files

```bash
# Stage ONLY files belonging to THIS group
git add path/to/file1.ext path/to/file2.ext

# Verify staged files match the group
git diff --staged --stat
```

### Step 3.4: Create Conventional Commit

```bash
git commit -m "type(scope): short description

- Detailed change 1
- Detailed change 2
- Detailed change 3

Closes #[issue-number]"
```

### Step 3.5: Push and Create PR

```bash
# Push feature branch
git push -u origin feature/FR-####-short-description

# Create PR
gh pr create \
  --base v{version}/development \
  --title "[PREFIX-####] PR Title matching issue" \
  --body "## Summary

[Description of changes]

## Related Issue

Closes #[issue-number]

## Changes

- Change 1
- Change 2

## Checklist

- [x] Conventional commits used
- [x] Files properly scoped
- [x] Issue linked"
```

**Capture the PR number** for monitoring.

---

## Phase 4: CI Monitoring

### Step 4.1: Wait for Checks

For **each PR created**, monitor CI/CD status:

```bash
# Watch checks until completion
gh pr checks [PR-number] --watch
```

### Step 4.2: Handle Failures

If any check fails:

1. **Analyze the failure**:
   ```bash
   gh run view [run-id] --log-failed
   ```

2. **Fix if possible** (lint errors, test failures, etc.)

3. **Commit and push fixes**:
   ```bash
   git add [fixed-files]
   git commit -m "fix: address CI feedback"
   git push
   ```

4. **Re-run if needed**:
   ```bash
   gh run rerun [run-id] --failed
   ```

5. **If unable to fix**: Report the blocker and continue with other groups

---

## Phase 5: Merge & Close

### Step 5.1: Merge PR

Once all checks pass:

```bash
# Squash merge (clean history) and delete branch
gh pr merge [PR-number] --squash --delete-branch
```

### Step 5.2: Verify Issue Closure

```bash
# Confirm issue was closed automatically
gh issue view [issue-number] --json state,stateReason
```

If issue not closed, close manually:

```bash
gh issue close [issue-number] --reason completed
```

---

## Phase 6: Repeat & Complete

### Step 6.1: Process All Groups

Repeat Phases 3-5 for **every logical group identified** in Phase 1.

### Step 6.2: Final Cleanup

```bash
# Return to development branch
git checkout v{version}/development

# Pull all merged changes
git pull origin v{version}/development

# Verify clean working directory
git status
```

---

## Phase 7: Final Report

Generate a comprehensive summary:

```markdown
## ‚úÖ Git Chaos Organized Successfully

**Repository**: [repo-name]
**Version**: {version}
**Target Branch**: v{version}/development
**Execution Time**: [start] ‚Üí [end]

---

### Summary Statistics

| Metric | Count |
|--------|-------|
| Files Analyzed | X |
| Logical Groups Identified | Y |
| Issues Created | Y |
| PRs Merged | Y |
| CI Checks Passed | Z |

---

### Work Completed

| # | Issue | Branch | PR | Status |
|---|-------|--------|-----|--------|
| 1 | #[num] [PREFIX-####] Title | `feature/...` | #[pr] | ‚úÖ Merged |
| 2 | #[num] [PREFIX-####] Title | `bugfix/...` | #[pr] | ‚úÖ Merged |

---

### Issues Created

1. **#[num]** ‚Äî [[PREFIX-####] Title](link)
2. **#[num]** ‚Äî [[PREFIX-####] Title](link)

---

### PRs Merged

1. **#[pr]** ‚Üí `v{version}/development` (squash merged)
2. **#[pr]** ‚Üí `v{version}/development` (squash merged)

---

### Repository State

- **Working Directory**: Clean ‚úÖ
- **Current Branch**: `v{version}/development`
- **All Changes**: Organized, tracked, and merged

---

**Your chaos has been transformed into clean, traceable development history! üéâ**
```

---

## Inputs

- `${input:scope:Optional - specific files or directories to organize}` ‚Äî If provided, limit analysis to these paths. If empty, analyze ALL uncommitted changes.

---

## Constraints

### MUST DO

- ‚úÖ Analyze ALL uncommitted changes thoroughly
- ‚úÖ Create separate issues for each logical group (never combine unrelated changes)
- ‚úÖ Use proper issue prefixes (FR-, BG-, HF-, TC-, SC-, PF-, DC-, IN-)
- ‚úÖ Query existing issues to determine next available ID
- ‚úÖ Use 4-digit zero-padded issue numbers (e.g., FR-0042)
- ‚úÖ Create conventional commits with proper type, scope, and body
- ‚úÖ Wait for CI/CD checks before merging
- ‚úÖ Target `v{version}/development` branch for all PRs
- ‚úÖ Verify issue closure after merge
- ‚úÖ Provide detailed final report

### MUST NOT

- ‚ùå Combine unrelated changes into a single issue/PR
- ‚ùå Force push or use destructive git commands
- ‚ùå Skip CI/CD checks
- ‚ùå Commit secrets, credentials, or sensitive data
- ‚ùå Merge failing PRs without explicit user approval
- ‚ùå Modify the development branch directly (always use feature branches)

### ON ERROR

- ‚ö†Ô∏è If CI fails and cannot be fixed: Report and continue with other groups
- ‚ö†Ô∏è If merge conflicts occur: Report and request user intervention
- ‚ö†Ô∏è If permissions denied: Report and halt that specific operation

---

## Quality Assurance

Before reporting completion, verify:

- [ ] All uncommitted changes have been processed
- [ ] Every change group has a corresponding GitHub issue
- [ ] All issues follow proper naming conventions with correct IDs
- [ ] Each issue has its own feature branch
- [ ] All commits follow conventional commit format
- [ ] All PRs target `v{version}/development`
- [ ] All CI/CD checks passed (or failures reported)
- [ ] All PRs successfully merged
- [ ] All related issues closed
- [ ] Feature branches deleted
- [ ] Working directory is clean
- [ ] Final summary report generated

---

## Execution Mode

**This is a FULLY AUTOMATED workflow.**

Proceed through all phases without pausing for confirmation unless:

1. A critical error requires user decision
2. CI checks fail and cannot be automatically resolved
3. Merge conflicts require manual resolution
4. The grouping of changes is ambiguous and could be done multiple ways

For all other cases: **analyze, create, commit, push, wait, merge, close, repeat, report.**
